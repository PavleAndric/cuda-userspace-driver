# kod # 
make_arr(0);  
printf("rez = %lx ff30 = %lx  080 = %lx  \n" , (*(uint64_t*)0x7ffff7fab080)-(*(uint64_t*)0x204a0ff38) , *((uint64_t*)0x204a0ff38) , *((uint64_t*)0x7ffff7fab080));
cuMemcpyDtoH(b , d_a , sizeof(int)*N);
printf("rez = %07lx ff30 = %lx  080 = %lx  \n" , (*(uint64_t*)0x7ffff7fab080)-(*(uint64_t*)0x204a0ff38) , *((uint64_t*)0x204a0ff38) , *((uint64_t*)0x7ffff7fab080));
make_arr(1);
compare();
# # # 

rez = 1cef0e0 ff30 = 2302b3b8520  080 = 2302d0a7760 | 2302d0afae0 - 2302b3b8520 =  0x1cf75c0
rez = 00011a0 ff30 = 2302d0afae0  080 = 2302d0b0dc0 | 2d0b0dc0 < 2d0afae0 


kada manjeas *((uint32_t*)0x204a0ff30) = 0x2; (pre je bilo 1) pre pozivanja cuMemcpyDtoH

rez = 1a87a60 ff30 = 27582ce69e0  080 = 2758476e5a0   ff30 osaje isti 
rez = 1a8bc60 ff30 = 27582ce69e0  080 = 27584772780  
82ce69e0->84772be0



# 
kada stavis usleep radi, izgleda da mora da se ceka nesto 

uint64_t stari = *((uint64_t*)0x204a0ff38);
print_needed();
cuMemcpyDtoH(b , d_a , sizeof(int)*N); //usleep(10000);
print_needed();
printf("novi - stari = %lx (fff) , novi = %lx, stari = %lx \n", *((uint64_t*)0x204a0ff38) - stari , *((uint64_t*)0x204a0ff38) , stari);


#### sa usleep
rez = 1c0e440 ff30 = 357827b6f20  080 = 357843c54a0  
rez = 0003200 ff30 = 35784da6e80  080 = 35784daa200  
novi - stari = 25eff60 (fff) , novi = 35784da6e80, stari = 357827b6f20  // 0x25eff60 / 0x540 
827b6f20->84da6e80 

00 01 02 03 04 05 06 07  , 00 01 02 03 04 05 06 07 


#### bez usleep
rez = 19bef20 ff30 = 36675ec8d60  080 = 36677887de0    ||||| ff30 je isto !!! 
rez = 19c3360 ff30 = 36675ec8d60  080 = 3667788c220  
novi - stari = 0 (fff) , novi = 36675ec8d60, stari = 36675ec8d60 
75ec8d60->7788c680 

00 00 00 00 00 00 00 00  , 00 01 02 03 04 05 06 07 



# moze i ovo da se desi , da zakasni , stari i novi su isti , ali  se posle  ff30 promeni
rez = 11b590c0 ff30 = 3d574a51ce0  080 = 3d5865aaee0  
rez = 11b61260 ff30 = 3d574a51ce0  080 = 3d5865b3080  
novi - stari = 11b60e20 (fff) , novi = 3d5865b2b00, stari = 3d574a51ce0 


###################

*((uint32_t*)0x204a0ff30) = 0x2;

print_needed();
sleep(1);
cuMemcpyDtoH(b , d_a , sizeof(int)*N); //usleep(10000);
print_needed();
printf("080 stari - novi = %lx  stari = %lx  , novi = %lx \n" ,*((uint64_t*)0x7ffff7fab080)- k_1 , *((uint64_t*)0x7ffff7fab080), k_1); //080 se smanjuje
printf("fff novi - stari = %lx , novi = %lx, stari = %lx \n", *((uint64_t*)0x204a0ff38) - stari , *((uint64_t*)0x204a0ff38) , stari);


rez = 17e0160 ff30 = 66f77440200  080 = 66f78c204a0  
rez = 34e0 ff30 = 66fb4614740  080 = 66fb4618180  
080 stari - novi = 3b9ffce0  stari = 66fb4620440, novi = 66f78c20200 
fff novi - stari = 3d1d4540 , novi = 66fb4614740, stari = 66f77440200  3d1d4540 > 3b9ffce0

00 01 02 03 04 05 06 07 

00 01 02 03 04 05 06 07

# bez  slipa
rez = 1931300 ff30 = 685342bd280  080 = 68535bee6e0  
rez = 193a580 ff30 = 685342bd280  080 = 68535bf7960  
080 stari - novi = 9de0  stari = 68535bf8380  , novi = 68535bee440 
fff novi - stari = 193ab60 , novi = 68535bf7de0, stari = 685342bd280 

00 00 00 00 00 00 00 00 

00 01 02 03 04 05 06 07 
###################

  
  ##### GLUPOSTI #####
  
  /*
  BEGIN_NVC0(push ,0x1, NVC5C0_OFFSET_OUT_UPPER, 0x2);
  //PUSH_DATAh(push,0x7fffcda00000);   
  PUSH_DATA(push,0x7fff);   
  PUSH_DATA(push,0xcda00000);
  BEGIN_NVC0(push ,0x1,NVC5C0_LINE_LENGTH_IN, 0x2);
  PUSH_DATA(push,0x14);  
  PUSH_DATA(push,0x1);
  BEGIN_NVC0(push ,0x1,NVC5C0_LAUNCH_DMA, 0x1);
  PUSH_DATA(push,0x41);
  BEGIN_NIC0(push ,0x1,NVC597_LOAD_INLINE_DATA, 0x5);
  PUSH_DATA(push,0x0);
  PUSH_DATA(push,0x1);
  PUSH_DATA(push,0x2);
  PUSH_DATA(push,0x3);
  PUSH_DATA(push,0x4);
  PUSH_DATA(push ,0x200426c0); //BEGIN_NVC0(push ,0x1 ,NVC597_SET_PS_OUTPUT_SAMPLE_MASK_USAGE, 0x4); // 200420c0 200426c0
  PUSH_DATA(push,0x2);
  PUSH_DATA(push,0x04a0fff0);
  PUSH_DATA(push,0x68);
  PUSH_DATA(push,0x0);
  */

//*ptr_1 = 0x434054;
//*ptr_2 = 0x4e02; 
//*ptr_3 = 0x4340a0; 
//*ptr_10 = 0x4340a0;  //*counter = *counter + 0x1;
//*ptr_4 = 0x68; 
//*ptr_5 = 0x68; //*bar  = 0x0;
//*(uint32_t*)0x204a0fff0 = 0x68;
//*(uint32_t*)0x204a0fff8 = *bar;


  /*for(uint32_t *ide_gas  = (uint32_t*)0x204a00000;  ide_gas <(uint32_t*)0x204c00000 ; ide_gas ++ ){
    if (*ide_gas != 0){
      printf("%p %x \n",ide_gas, *ide_gas);
    }
  }*/


  //munmap((void*)0x200200000 ,0x200400000-0x200200000);  
  //mmap((void*)0x200200000, 0x200400000-0x200200000, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

  /*
  uint32_t *ptr_1 =  (uint32_t*)0x200200338;
  uint32_t *ptr_2 =  (uint32_t*)0x20020033c;
  uint32_t *ptr_3 =  (uint32_t*)0x200202040;
  uint32_t *ptr_10 = (uint32_t*)0x200202044;
  uint32_t *ptr_4 =  (uint32_t*)0x200202088;
  uint32_t *ptr_5 =  (uint32_t*)0x20020208c;

  uint32_t *counter =  (uint32_t*)0x204a0fff0;
  uint32_t *dont_know =  (uint32_t*)0x204a0fff8;

  uint64_t *bar =  ((uint64_t*)0x7ffff7fab080);
  uint32_t vr[3];
  */

//kada se munmapuje i ponovo mapira 0x200400000-0x200200000
//samo napravi nekoliko stvari  


  /*std::thread t([](){ // 
    while(1){
      for (uint32_t * p=  (uint32_t*)0x7ffff7fab000 ;p < (uint32_t*)0x7ffff7fbb000 ; p ++){
        if (*p){ printf("%p: %x \n" , p , *p); }
      }
    }
    usleep(50 *10000);
  });*/
